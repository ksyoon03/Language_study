# 재귀 함수

<aside>

### 개념

- 함수 내부에서 자기 자신을 다시 호출하는 함수
</aside>

<aside>

### 핵심 요소

- **기저 사례**
    - 더 이상 재귀 호출을 하지 않고 함수를 종료하는 조건
    - 이 조건이 없으면 함수는 무한히 자기 자신을 호출하게 되어 스택 오버플로우가 발생한다.
- **재귀 호출**
    - 함수가 자기 자신을 호출하는 부분
    - 이때 함수는 점점 더 작은 단위로 줄어들어야 한다.

### 예시

- 팩토리얼 계산

```cpp
#include <iostream>

using namespace std;

// 팩토리얼을 계산하는 재귀 함수
long long factorial(int n) {
    // 1. 기저 사례: n이 1일 때 재귀를 멈춤
    if (n == 1) {
        return 1;
    }

    // 2. 재귀 호출: n * (n-1)! 을 계산
    return n * factorial(n - 1);
}

int main() {
    int num = 5;
    cout << num << "! = " << factorial(num) << endl;
    return 0;
}
```

출력 결과:

```cpp
5 != 120
```

</aside>

<aside>

### 장단점

- **장점**
    - 문제를 직관적이고 간결한 코드로 표현할 수 있다.
    - 복잡한 반복문 구조 없이 문제를 해결할 수 있다.
- **단점**
    - 메모리 사용량이 크다. 함수가 호출될 때마다 스택에 정보가 쌓이기 때문에, 너무 깊어지면 스택 오버플로우가 발생할 수 있다.
    - 함수 호출 과정에서 발생하는 오버헤드 때문에 반복문보다 느릴 수 있다.
</aside>