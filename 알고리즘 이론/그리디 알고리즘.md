# 그리디 알고리즘

## 그리디(Greedy : 탐욕스러운) 알고리즘

- 현재 상황에서 **가장 최적이라고 생각되는 선택**을 하는 방식으로 답을 찾는 알고리즘
- 각 단계에서 가장 좋은 선택만을 반복하여 최종 해답에 도달하는 방식

## 그리디 알고리즘의 특징

- **탐욕적인 선택 속성** (Greedy Choice Property)
    - 앞서 한 선택이 이후의 선택에 영향을 주지 않음
    - 매 순간 최적의 선택이 전체 문제의 최적 해답을 보장함
- **최적 부분 구조** (Optimal Substructure)
    - 문제의 최적 해답이 그 하위 문제의 최적 해답들로 구성됨
    - 큰 문제의 해결 방법이 작은 문제의 해결 방법과 동일함

## 그리디 알고리즘의 한계

- 매 순간 최적의 선택이 전체 문제의 최종적인 최적 해답을 이끌지 못할 수도 있기 때문에 항상 최적의 해를 보장하는 것은 아님
- 그리디 알고리즘을 사용하기 전에는 해당 문제가 **탐욕적인 선택 속성**과 **최적 부분 구조**를
    
    만족하는지 반드시 확인해야함
    

## 그리디 알고리즘의 예시

### 거스름돈 문제

- **문제 상황:** 500원, 100원, 50원, 10원짜리 동전이 있을 때, 손님에게 거슬러 줄 N원을 가장 적은 수의 동전으로 주는 방법은?
- **그리디 해법:** 가장 큰 단위의 동전부터 최대한 많이 사용하면 된다.
    
    ex) 1260원을 거슬러 줘야하는 상황: 
    
    1. 500원 → 2개 (1000원)
    2. 100원 → 2개 (200원)
    3. 50원 → 1개 (50원)
    4. 10원 → 1개 (10원)
- **결과:** 총 6개의 동전으로 거슬러 줄 수 있다.
- **예시 코드:**
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    int main() {
    	int money, cnt = 0;
    	cin >> money;
    	
    	while (money > 0) {
    		if (money >= 500) {
    			money -= 500;
    			cnt++;
    		}
    		else if (money < 500 && money >= 100) {
    			money -= 100;
    			cnt++;
    		}
    		else if (money < 100 && money >= 50) {
    			money -= 50;
    			cnt++;
    		}
    		else if (money < 50 && money >= 10) {
    			money -= 10;
    			cnt++;
    		}
    	}
    	cout << cnt << endl;
    }
    ```